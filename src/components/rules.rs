use yew::prelude::*;

use crate::components::appointment::Appointment;

use chrono::{NaiveDate, NaiveTime, Weekday};

use wasm_bindgen::__rt::std::collections::HashSet;

pub enum Message {
    CheckStartIRule(usize),
    CheckEndIRule(usize),
    Test,
}

pub enum RuleTypes {
    IRule(IntervalRule),
    WRule(WeekdayRule),
}

pub trait Rule {
    /// returns the name of an event generated by this rule
    fn get_name(&self) -> String;
    /// returns the description of an event generated by this rule
    fn get_description(&self) -> String;
    /// computes all occurrences of this rule in a given week of a given year
    fn get_occurrences_in_week(&self, year: i32, week: u32) -> Vec<Appointment>;
}

/// Nav component
pub struct Rules {
    link: ComponentLink<Self>,
    state: State,
}

pub struct State {
    rules: Vec<RuleTypes>
}

pub struct IntervalRule {
    id: usize,
    start_date: NaiveDate,
    interval: i64,
    name: String,
    description: String,
    start: Option<NaiveTime>,
    end: Option<NaiveTime>,
}

impl Rule for IntervalRule {
    fn get_name(&self) -> String {
        self.name.clone()
    }
    fn get_description(&self) -> String {
        self.description.clone()
    }
    fn get_occurrences_in_week(&self, year: i32, week: u32) -> Vec<Appointment> {
        let mut result = Vec::new();
        let weekdays = vec!(Weekday::Mon, Weekday::Tue, Weekday::Wed, Weekday::Thu, Weekday::Fri, Weekday::Sat, Weekday::Sun);
        for day in weekdays {
            let date = NaiveDate::from_isoywd(year, week, day);
            let difference = date - self.start_date;
            if difference.num_days() % self.interval == 0 {
                result.push(Appointment::new(
                    date,
                    self.start,
                    self.end,
                    self.name.clone(),
                    self.description.clone(),
                ));
            }
        }
        result
    }
}

#[cfg(test)]
mod interval_rule_impl_tests {
    use chrono::{NaiveDate, NaiveTime, Weekday};

    use crate::components::appointment::Appointment;
    use crate::components::rules::{Rule, IntervalRule};

    #[test]
    fn test_occurrences() {
        let start_date = NaiveDate::from_isoywd(2020, 02, Weekday::Mon);
        let start = Some(NaiveTime::from_hms(10, 0, 0));
        let end = Some(NaiveTime::from_hms(12, 0, 0));
        let name = "name".to_string();
        let description = "desc".to_string();

        let ir = IntervalRule {
            id: 1,
            start_date,
            interval: 2,
            name: name.clone(),
            description: description.clone(),
            start,
            end,
        };

        let app0 = Appointment::new(
            NaiveDate::from_isoywd(2020, 03, Weekday::Tue),
            start,
            end,
            name.clone(),
            description.clone(),
        );
        let app1 = Appointment::new(
            NaiveDate::from_isoywd(2020, 03, Weekday::Thu),
            start,
            end,
            name.clone(),
            description.clone(),
        );
        let app2 = Appointment::new(
            NaiveDate::from_isoywd(2020, 03, Weekday::Sat),
            start,
            end,
            name.clone(),
            description.clone(),
        );
        let reference_result = vec!(app0, app1, app2);

        assert_eq!(reference_result[0], app0);
        assert_eq!(reference_result[1], app1);
        assert_eq!(reference_result[2], app2);
    }
}


impl IntervalRule {
    pub fn new(id: usize,
               start_date: NaiveDate,
               interval: i64,
               name: String,
               description: String,
               start: Option<NaiveTime>,
               end: Option<NaiveTime>) -> IntervalRule {
        IntervalRule {
            id,
            start_date,
            interval,
            name,
            description,
            start,
            end,
        }
    }
    pub fn get_id(&self) -> usize {
        self.id
    }
    pub fn get_start_date(&self) -> NaiveDate {
        self.start_date
    }
    pub fn get_interval(&self) -> i64 {
        self.interval
    }
    pub fn get_start(&self) -> Option<NaiveTime> {
        self.start
    }
    pub fn get_start_string(&self) -> String {
        match self.start {
            Some(s) => s.to_string().clone(),
            None => "".to_string()
        }
    }
    pub fn get_has_start_time(&self) -> bool {
        match self.start {
            Some(_) => true,
            None => false
        }
    }
    pub fn set_start(&mut self, time: Option<NaiveTime>) {
        self.start = time;
    }
    pub fn get_end(&self) -> Option<NaiveTime> {
        self.end
    }
    pub fn get_end_string(&self) -> String {
        match self.end {
            Some(s) => s.to_string().clone(),
            None => "".to_string()
        }
    }
    pub fn get_has_end_time(&self) -> bool {
        match self.end {
            Some(_) => true,
            None => false
        }
    }
    pub fn set_end(&mut self, time: Option<NaiveTime>) { self.end = time; }
}


pub struct WeekdayRule {
    weekdays: HashSet<Weekday>
}

impl Component for Rules {
    type Message = Message;
    type Properties = ();

    fn create(_: Self::Properties, link: ComponentLink<Self>) -> Self {
        let r0: RuleTypes = RuleTypes::IRule(
            IntervalRule::new(
                0,
                NaiveDate::from_isoywd(2020, 02, Weekday::Sat),
                2,
                "test".to_string(),
                "testdesc".to_string(),
                None,
                None,
            )
        );

        let state = State {
            rules: vec!(r0)
        };


        Rules {
            link,
            state,
        }
    }

    fn update(&mut self, msg: Self::Message) -> ShouldRender {
        match msg {
            Message::CheckStartIRule(irule) => {
                let element = &mut self.state.rules[irule];
                match element {
                    RuleTypes::IRule(rule) => {
                        if rule.get_has_start_time() {
                            rule.set_start(None);
                        } else {
                            rule.set_start(Some(NaiveTime::from_hms(0, 0, 0)));
                        }
                    }
                    RuleTypes::WRule(_rule) => {}
                }
            },
            Message::CheckEndIRule(rule) => {
                let element = &mut self.state.rules[rule];
                match element {
                    RuleTypes::IRule(rule) => {
                        if rule.get_has_end_time() {
                            rule.set_end(None);
                        } else {
                            rule.set_end(Some(NaiveTime::from_hms(0, 0, 0)));
                        }
                    }
                    RuleTypes::WRule(_rule) => {}
                }
            },
            Message::Test => {}
        }
        true
    }

    fn change(&mut self, _: Self::Properties) -> ShouldRender {
        false
    }

    fn view(&self) -> Html {
        html! {
            <table class="table table-striped">
                <tbody>
                { for self.state.rules.iter().map(|rule| self.view_entry(rule)) }
                </tbody>
            </table>
        }
    }
}

impl Rules {
    fn view_entry(&self, rule: &RuleTypes) -> Html {
        match rule {
            RuleTypes::IRule(r) => {
                let id = r.get_id();
                html! {<tr>
                            <td>
                                <h4>{ "Intervallregel: " }</h4>
                                <form class="form-inline">
                                    <div class="form-group">
                                        <label for="input_name">{ "Name:" }</label>
                                        <input id="input_name" type="text" class="form-control ml-1" value=r.get_name().to_string()/>
                                    </div>
                                    <div class="form-group ml-2">
                                        <label for="input_start_date">{ "Startdatum: " }</label>
                                        <input id="input_start_date" type="date" class="form-control ml-1" value=r.get_start_date().to_string()/>
                                    </div>
                                    <div class="form-group ml-2">
                                        <label for="input_interval">{ "Intervall:" }</label>
                                        <input id="input_interval" type="number" class="form-control ml-1" value=r.get_interval().to_string()/>
                                    </div>
                                     <div class="form-group form-check ml-2">
                                        <label class="form-check-label" for="input_start_time_active">{ "Hat Anfang: " } </label>
                                        <input type="checkbox" class="form-check-input ml-1" id="input_start_time_active" checked=r.get_has_start_time() onchange=self.link.callback(move |_| Message::CheckStartIRule(id))/>
                                    </div>
                                    <div class="form-group ml-2">
                                        <label for="input_start_time">{ "Startzeit:" }</label>
                                        <input id="input_start_time" type="time" class="form-control ml-1" value=r.get_start_string() disabled=!r.get_has_start_time() />
                                    </div>
                                    <div class="form-group form-check ml-2">
                                        <label class="form-check-label" for="input_end_time_active"> { "Hat Ende:" } </label>
                                        <input type="checkbox" class="form-check-input ml-1" id="input_end_time_active" checked=r.get_has_end_time() onchange=self.link.callback(move |_| Message::CheckEndIRule(id))/>
                                    </div>
                                    <div class="form-group ml-2">
                                        <label for="input_end_time">{ "Endzeit:" }</label>
                                        <input id="input_end_time" type="time" class="form-control ml-1" value=r.get_end_string() disabled=!r.get_has_end_time()/>
                                    </div>

                                </form>
                            </td>
                       </tr>}
            }
            RuleTypes::WRule(_r) => {
                html! {<tr>{"found Wrule"}</tr>}
            }
        }
    }
}